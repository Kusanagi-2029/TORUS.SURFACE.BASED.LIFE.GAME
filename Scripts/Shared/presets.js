/**
 * Модуль, содержащий функции заполнения шаблонами.
 */
import { fillMap } from './mapFunctions.js';

/**
 * Использование генераторов случайных чисел с более высокой производительностью:
 * Вместо использования Math.random() для каждой ячейки можно использовать более быстрый и 
 * менее предсказуемый генератор случайных чисел, такой как Xorshift или Marsaglia xorshift.
 * 
 * Функция-Генератор псевдослучайных чисел с использованием Xorshift
 */
function xorshift(seed) {
    let x = seed; // Инициализация переменной x значением seed

    return () => { // Возврат анонимной функции
        // Применение операций сдвига и побитового исключающего ИЛИ к переменной x
        x ^= x << 13; // Побитовое исключающее ИЛИ с левым сдвигом на 13 битов
        x ^= x >> 17; // Побитовое исключающее ИЛИ с правым сдвигом на 17 битов
        x ^= x << 5; // Побитовое исключающее ИЛИ с левым сдвигом на 5 битов
        // Нормализация числа от 0 до 1 и возврат его значения
        return ((x < 0 ? ~x + 1 : x) % 100) / 100;
    };
}

/**
 * Функция заполнения Map'ы жизни шаблонами.
 * @param {number} width - Ширина Map'ы жизни.
 * @param {number} height - Высота Map'ы жизни.
 * @returns {Array} - Map'а жизни.
 */
export const fillFunctions = [
    ['Прямоугольная Случайность', (w, h) => {
        const randomPoints = []; // Создание пустого массива для хранения точек
        const di = Math.floor(w / 4); // Вычисление шага по оси x
        const dj = Math.floor(h / 4); // Вычисление шага по оси y
        const rand = xorshift(Date.now()); // Создание генератора случайных чисел

        // Вложенные циклы для обхода всех точек с шагом di и dj
        for (let j = 0; j < h / 2; ++j) {
            for (let i = 0; i < w / 2; ++i) {
                // Генерация случайного числа и добавление точки в массив randomPoints с вероятностью 0.4
                if (rand() < 0.4) {
                    randomPoints.push({ x: i + di, y: j + dj });
                }
            }
        }
        return randomPoints; // Возврат массива с сгенерированными точками
    }],

    /** Создает объект, представляющий тяжеловесную случайность, 
     * заполняющую игровое поле случайным образом. 
     * Функция принимает ширину (w) и высоту (h) игрового поля и возвращает массив объектов 
     * с координатами заполненных клеток. Вероятность заполнения клетки задается значением 0.1. */
    ['Тяжеловесная Случайность', (w, h) => {
        const randomPoints = []; // Создание пустого массива для хранения точек
        const di = Math.floor(w / 500); // Вычисление шага по оси x
        const dj = Math.floor(h / 500); // Вычисление шага по оси y
        const rand = xorshift(Date.now()); // Создание генератора случайных чисел

        // Вложенные циклы для обхода всех точек с шагом di и dj
        for (let j = 0; j < h; ++j) {
            for (let i = 0; i < w; ++i) {
                // Генерация случайного числа и добавление точки в массив randomPoints с вероятностью 0.1
                if (rand() < 0.1) {
                    randomPoints.push({ x: i + di, y: j + dj });
                }
            }
        }
        return randomPoints; // Возврат массива с сгенерированными точками
    }],

    /** Создает функцию, которая генерирует случайное распределение 
     * клеток на игровом поле с вероятностью заполнения клетки 50%. 
     * Созданная область заполнения представляет собой прямоугольник, случайно выбранный на поле. */
    ['Прямоугольная Хаотичная Случайность', (w, h) => {
        const randomPoints = []; // Создаем пустой массив для хранения координат заполненных клеток
        const di = Math.floor(w / 400); // Вычисляем шаг по горизонтали
        const dj = Math.floor(h / 400); // Вычисляем шаг по вертикали
        const probability = 0.5; // Вероятность заполнения клетки
        const threshold = Math.floor(probability * 100); // Вычисляем порог для случайной генерации
        const rand = xorshift(Date.now()); // Создаем генератор случайных чисел на основе текущего времени

        // Генерируем случайные координаты для начала и конца области заполнения
        let startX = Math.floor(rand() * w);
        let startY = Math.floor(rand() * h);
        let endX = Math.floor(rand() * (w - startX)) + startX;
        let endY = Math.floor(rand() * (h - startY)) + startY;

        // Заполняем область, определенную сгенерированными координатами
        for (let j = startY; j < endY; j++) {
            for (let i = startX; i < endX; i++) {
                // Генерируем случайное число для каждой ячейки в области
                const randomValue = Math.floor(rand() * 100);
                // Проверяем, меньше ли сгенерированное число порога
                if (randomValue < threshold) {
                    // Если да, добавляем координаты текущей клетки с учетом шага di и dj
                    randomPoints.push({ x: i + di, y: j + dj });
                }
            }
        }
        return randomPoints; // Возвращаем массив с координатами заполненных клеток
    }],

    ['Астероид', fillMap({ top: 0, left: 0, useSquareCorner: true }, [
        [0, 1, 0],   // Определяем шаблон астероида, где 1 представляет заполненную клетку, а 0 - пустую
        [1, 0, 0],   // Заполненные клетки образуют форму астероида
        [1, 1, 1],
    ])],

    ['Ракета (Обратный Астероид)', fillMap({ top: 0, left: 0, useSquareCorner: true }, [
        [1, 1, 1],   // Определяем шаблон астероида, где 1 представляет заполненную клетку, а 0 - пустую
        [0, 0, 1],   // Заполненные клетки образуют форму астероида
        [0, 1, 0],
    ])],
];